{"/about/":{"data":{"":"This is the about page."},"title":"About"},"/docs/deployment/":{"data":{"":"Information related to self-hosting topics.\nQuick start Configuration "},"title":"Deployment"},"/docs/deployment/configuration/":{"data":{"":"","environmental-variables#Environmental variables":"Required Variable Example Description STAGE prod Stage is used for building widget js code (e.g. minification) and for separation in logging. PC_PORTAL_BASE_URL portal.yourdomain.com (Sub)domain where you will host PrivateCaptcha portal. PC_API_BASE_URL api.yourdomain.com (Sub)domain where CAPTCHA API (puzzles, verification etc.) will be hosted. PC_CDN_BASE_URL cdn.yourdomain.com (Sub)domain where CDN assets will be hosted (e.g., client-side widget package, pictures, email assets etc.). PC_ADMIN_EMAIL admin@yourdomain.com Email that will be used for admin user to login. Must be valid and functioning. PC_EMAIL_FROM no-reply@yourdomain.com Sender address for various transactional emails (2FA auth, welcome email etc.) PC_POSTGRES postgres://username:pass@postgres:5432/privatecaptcha Postgres connection string for backend DB. You can also specify separate values (see note below). PC_CLICKHOUSE_HOST clickhouse Host (or IP address) where ClickHouse DB is running. PC_CLICKHOUSE_DB privatecaptcha Database for connecting to ClickHouse. PC_CLICKHOUSE_USER captcha Username for connecting to PC_CLICKHOUSE_DB. PC_CLICKHOUSE_PASSWORD qwerty12345 Password for PC_CLICKHOUSE_USER. PC_USER_FINGERPRINT_KEY abcdef... HEX-encoded 64-character string, used as IV value for hashing user fingerprints. PC_API_SALT asdf... String used as salt for creating puzzle signatures. SMTP_ENDPOINT smtp://your.provider.com:587 Endpoint used for sending transactional email. SMTP_USERNAME foobar Username for SMTP_ENDPOINT. SMTP_PASSWORD qwerty12345 Password for SMTP_USERNAME. Note\nInstead of PC_POSTGRES as a connection string, you can specify PC_POSTGRES_HOST, PC_POSTGRES_DB, PC_POSTGRES_USER, PC_POSTGRES_PASSWORD separately.\nOptional Variable Example Description PC_HOST localhost Host where to listen for HTTP connections. PC_PORT 8080 Port where to listen for HTTP connections. PC_LOCAL_ADDRESS localhost:9090 Local “admin” endpoint that hosts Prometheus metrics, manual maintenance jobs triggers and kubernetes liveness/readiness probes. Does not have any auth and must not be exposed publicly. PC_RATE_LIMIT_HEADER X-Real-Ip HTTP header which will contain IP address of the connecting user. Is expected to come from CDN or proxy (e.g., nginx, caddy). If empty, righmost non-private address of X-Forwarded-For will be used. PC_RATE_LIMIT_RPS 1.0 Leak rate per second (float) of default API rate limiter. PC_RATE_LIMIT_BURST 20 Burst of default API rate limiter. PC_CLICKHOUSE_ADMIN captcha_admin Separate username for ClickHouse to run migrations with. If empty, PC_CLICKHOUSE_USER will be used. PC_CLICKHOUSE_ADMIN_PASSWORD qwerty12345 Password for PC_CLICKHOUSE_ADMIN. PC_POSTGRES_ADMIN captcha_admin Separate username for Postgres to run migrations with. If empty, PC_POSTGRES_USER (or PC_POSTGRES) will be used. PC_POSTGRES_ADMIN_PASSWORD qwerty12345 Password for PC_POSTGRES_ADMIN. PC_MAINTENANCE_MODE true Boolean (1, y, true) value if server is in maintenance mode, during which communications with databases are offline, but APIs (and cache) are functional. PC_REGISTRATION_ALLOWED true Boolean (1, y, true) value if this instance of PrivateCaptcha has registration page open. PC_HEALTHCHECK_INTERVAL 60 Integer value that defines how frequently in seconds we perform internal health check of DB instances and http server. Defaults to 5 in prod and 60 in dev. PC_VERBOSE true Boolean (1, y, true) to indicate verbose logging (trace level). Note\n“Default” rate limiter means the one for public APIs (/puzzle, /siteverify and some others). Various other APIs have pre-configured hardcoded limits, compiled in.\nWarning\nIt’s not recommended to modify leak rate configuration unless you really know what you’re doing."},"title":"Configuration"},"/docs/deployment/quickstart/":{"data":{"1-clone-the-self-hosting-repo#1. Clone the self-hosting repo":"","2-create-env-file#2. Create \u003ccode\u003e.env\u003c/code\u003e file":"Quick startPrerequisites Docker installed (optional) Reverse proxy like Caddy or Nginx Domain name yourdomain.com (for local-only installs, use privatecaptcha.local) Transactional email provider with SMTP credentials (for production) At least 2GB of RAM 1. Clone the self-hosting repo Self-hosting repository contains a Docker-based quickstart template.\ngit clone https://github.com/PrivateCaptcha/self-hosting.git private-captcha cd private-captcha 2. Create .env file cp .env.example .env Some notes on environment variables:\nPC_USER_FINGERPRINT_KEY you can generate using openssl rand -hex 64 PC_ADMIN_EMAIL will be used to create actual admin account (see note for local use below) PC_RATE_LIMIT_HEADER should be the header containing actual client IP (comes from your CDN or reverse proxy) You can find full documentation on these and other required environment variables here.\nTips for local use To run Private Captcha only locally, use privatecaptcha.local:8080 instead of yourdomain.com. To make it work, you need to add a few lines to /etc/hosts file:\n127.0.0.1 portal.privatecaptcha.local 127.0.0.1 api.privatecaptcha.local 127.0.0.1 cdn.privatecaptcha.local NOTE: email with .local domain is not a valid RFC-5322 address, so for 2FA code (required for login) you will need to find “two factor code” from docker logs manually","3-optional-expose-port#3. (optional) Expose port":"By default Private Captcha is listening on http://localhost:8080. If you want to use Docker networking for production directly (which is not recommended) instead of reverse proxy like Nginx or Caddy, you can create a compose.override.yml file like this:\nservices: privatecaptcha: ports: - 8080:8080 ","4-navigate-to-the-portal#4. Navigate to the Portal":"Now you can open $PC_PORTAL_BASE_URL (e.g. portal.yourdomain.com or http://portal.privatecaptcha.local) in browser and log in.\nNOTE: For local-only use, when asked for a verification code, you might need to find it in the logs of privatecaptcha container. Search for “two factor code”.","prerequisites#Prerequisites":"","quick-start#Quick start":""},"title":"quickstart"},"/docs/integrations/":{"data":{"":"It is recommended to use one of the pre-built integrations. They use a more efficient API than reCAPTCHA-compatible /siteverify API, include retry mechanism and are officially supported.\nWordPressWordPress plugin All-in-one GoServer-side Golang library Server-side PHPServer-side PHP library Server-side PythonServer-side Python library Server-side .NETServer-side .NET/C# library Server-side JavascriptServer-side Javascript library Server-side ReactClient-side captcha component Client-side OpenAPIOpenAPI/Swagger API definition Server-side "},"title":"Integrations"},"/docs/integrations/dotnet/":{"data":{"":" Note\nYou can also use reCAPTCHA-compatible /siteverify endpoint directly (especially if you already have working reCAPTCHA integration) like in the tutorial example, this SDK is just C#-idiomatic implementation with convenience features.\nThis is a server-side SDK, which you would use to verify captcha solution against Private Captcha API. This SDK does not solve puzzles on the client side (used to protect APIs).\nGitHub repository","installation#Installation":"You can install the package via the .NET CLI or the NuGet Package Manager Console.\n.NET CLI\ndotnet add package PrivateCaptcha Package Manager Console\nInstall-Package PrivateCaptcha ","usage#Usage":"Basic Verification To verify a CAPTCHA solution, instantiate PrivateCaptchaClient with your configuration and call VerifyAsync.\nvar config = new PrivateCaptchaConfiguration { ApiKey = \"YOUR_API_KEY\" }; var captchaClient = new PrivateCaptchaClient(config); var result = await captchaClient.VerifyAsync(new VerifyInput { Solution = captchaSolution }); if (result.Success) { Console.WriteLine(\"Captcha verification succeeded!\"); } else { // Verification failed, you can check the reason. Console.WriteLine($\"Verification failed: {result.GetErrorMessage()}\"); } ASP.NET Core Middleware For web applications, the most convenient way to protect your endpoints is by using the provided middleware. It automatically intercepts POST requests with form data and verifies the CAPTCHA solution.\n1. Register PrivateCaptchaClient for Dependency Injection\nIn your Program.cs (for .NET 6+ minimal APIs) or Startup.cs, register the PrivateCaptchaClient.\n// Program.cs using PrivateCaptcha; var builder = WebApplication.CreateBuilder(args); builder.Services.AddSingleton(sp =\u003e { var config = new PrivateCaptchaConfiguration { ApiKey = \"YOUR_API_KEY\" }; return new PrivateCaptchaClient(config); }); 2. Add the Middleware to the Request Pipeline\nAdd app.UsePrivateCaptcha() to your request pipeline. It should be placed before the endpoints you want to protect.\nvar app = builder.Build(); // ... other middleware // Use the PrivateCaptcha middleware. This will automatically check POST requests // with a form content type for a valid captcha solution. app.UsePrivateCaptcha(); // This endpoint will now be protected by the CAPTCHA middleware. app.MapPost(\"/register\", () =\u003e \"Registration successful!\"); app.Run(); If verification fails, the middleware will short-circuit the request and return a 403 Forbidden status code by default (can be changed in the configuration).\nConfiguration You can customize the client’s behavior by passing a PrivateCaptchaConfiguration object to the constructor.\nProperty Description Default Value ApiKey (Required) Your API key from the Private Captcha dashboard. string.Empty Domain The API domain to use (use Domains.EU or an override in case of self-hosting) Domains.Global FormField The name of the form field containing the CAPTCHA solution. Used by the middleware. \"private-captcha-solution\" FailedStatusCode The HttpStatusCode to return when middleware verification fails. HttpStatusCode.Forbidden (403) HttpClient An optional HttpClient instance. If not provided, a new one will be created and managed by the client. null Non-standard backend domains For EU isolation, you can use built-in constant Domains.EU:\nvar config = new PrivateCaptchaConfiguration { ApiKey = \"YOUR_API_KEY\", Domain = Domains.EU }; var client = new PrivateCaptchaClient(config); Retry configuration When verifying puzzle solutions, you can also specify some retry and backoff options.\nvar input = new VerifyInput { Solution = \"captcha-solution\", MaxBackoffSeconds = 30, MaxAttempts = 10 }; Error Handling VerifyOutput: The VerifyAsync method returns a VerifyOutput object. Check the Success property to see if verification passed. If Success is false, the Code property and GetErrorMessage() method provide more details. VerificationFailedException: Thrown when the client cannot get a definitive success/fail response from the API after all retry attempts. This typically indicates a network issue. ArgumentException: Thrown by VerifyAsync if the provided VerifyInput.Solution is null or empty. "},"title":".NET"},"/docs/integrations/go/":{"data":{"":" Note\nYou can also use reCAPTCHA-compatible /siteverify endpoint directly (especially if you already have working reCAPTCHA integration) like in the tutorial example, this SDK is just Golang-idiomatic implementation with convenience features.\nThis is a server-side SDK, which you would use to verify captcha solution against Private Captcha API. This SDK does not solve puzzles on the client side (used to protect APIs).\nGitHub repository","installation#Installation":" go get -u github.com/PrivateCaptcha/private-captcha-go ","usage#Usage":"Import and instantiation Add import:\nimport pc \"github.com/PrivateCaptcha/private-captcha-go\" Create the client:\nclient, err := pc.NewClient(pc.Configuration{APIKey: \"pc_abcdef\"}) // ... handle err Configuration object allows to switch to EU endpoint, specify default form field for the solution, HTTP client, and status code for middleware version.\nVerify solution directly Verify() supports automatic backoff and retrying (configured via VerifyInput parameter), enabled by default. You need to check the captcha verification status yourself.\noutput, err := client.Verify(ctx, pc.VerifyInput{Solution: solution}) // ... handle err if !output.Success { fmt.Printf(\"Captcha verification failed. Error: %s\", result.Error()) } Wrapper around HTTP request VerifyRequest() operates on the http.Request level, extracts and verifies form field, configured via Configuration object for the client instance, with standard defaults. You only need to check if the err == nil.\nfunc handler(w http.ResponseWriter, r *http.Request) { if err := client.VerifyRequest(r.Context(), r); err != nil { return } } Simple HTTP middleware VerifyFunc() is a basic HTTP middleware that returns http.StatusForbidden (configured via Configuration object for client instance) if the captcha solution is not verified.\nmux.Handle(\"POST /my/form\", client.VerifyFunc(actualHandler)) Configuration Client configuration allows to set default form field, domain (can be used for self-hosting or EU isolation) and HTTP status for middleware version.\nNon-standard backend domains For EU isolation, you can use built-in constant EUDomain:\nclient, err := pc.NewClient(pc.Configuration{Domain: pc.EUDomain}) // ... handle err For self-hosted installation, use API domain name.\nRetry configuration When verifying puzzle solutions, you can also specify some retry and backoff options.\ninput := pc.Configuration{ Solution: \"solution\", MaxBackoffSeconds: 10, Attempts: 10, } output, err := client.Verify(ctx, input) // ... handle err "},"title":"Go"},"/docs/integrations/javascript/":{"data":{"":" Note\nYou can also use reCAPTCHA-compatible /siteverify endpoint directly (especially if you already have working reCAPTCHA integration) like in the tutorial example, this SDK is just Javascript-idiomatic implementation with convenience features.\nThis is a server-side SDK, which you would use to verify captcha solution against Private Captcha API. This SDK does not solve puzzles on the client side (used to protect APIs).\nGitHub repository","installation#Installation":" npm install private-captcha-js ","usage#Usage":"Basic Verification verify() supports automatic backoff and retrying (configured via VerifyInput parameter), enabled by default. You need to check the captcha verification status yourself.\nimport { createClient } from 'private-captcha-js'; const client = createClient({ apiKey: 'your-api-key' }); const result = await client.verify({ solution: 'captcha-solution-from-client' }); if (result.success) { console.log('Captcha verified!'); } Express.js Middleware middleware() returns a basic Express.js middleware that extracts and verifies form field, configured via Configuration object for the client instance.\nimport express from 'express'; import { createClient } from 'private-captcha-js'; const app = express(); app.use(express.urlencoded({ extended: true })); // Required const client = createClient({ apiKey: 'your-api-key' }); // Protect route with middleware app.post('/submit', client.middleware(), (req, res) =\u003e { res.send('Form submitted successfully!'); }); // Or verify manually app.post('/verify', async (req, res) =\u003e { try { const result = await client.verifyRequest(req); res.json({ success: result.success }); } catch (error) { res.status(403).json({ error: error.message }); } }); Configuration Client configuration allows to set default form field, domain (can be used for self-hosting or EU isolation) and HTTP status for middleware version.\nconst client = createClient({ apiKey: 'your-api-key', // Required formField: 'private-captcha-solution', // Field from where to read the solution failedStatusCode: 403, // HTTP status code for failed verifications (middleware) domain: 'api.privatecaptcha.com' // Override for EU isolation or for self-hosting }); Retry configuration When verifying puzzle solutions, you can also specify some retry and backoff options.\nclient.verify({ solution: 'solution', maxBackoffSeconds: 10, attempts: 10 }); "},"title":"Javascript"},"/docs/integrations/openapi/":{"data":{"":"You can use our OpenAPI specification file for exploring API or generating missing or custom integrations. For example, this is one of the most popular open-source tools to generate an API client.\nClick here for an OpenAPI (Swagger) playground link."},"title":"OpenAPI"},"/docs/integrations/php/":{"data":{"":" Note\nYou can also use reCAPTCHA-compatible /siteverify endpoint directly (especially if you already have working reCAPTCHA integration) like in the tutorial example, this SDK is just PHP-idiomatic implementation with convenience features.\nThis is a server-side SDK, which you would use to verify captcha solution against Private Captcha API. This SDK does not solve puzzles on the client side (used to protect APIs).\nGitHub repository","configuration#Configuration":"Client configuration allows to set default form field and domain (can be used for self-hosting or EU isolation).\nClient Options \u003c?php use PrivateCaptcha\\Client; $client = new Client( apiKey: \"your-api-key\", domain: Client::EU_DOMAIN, // replace domain for self-hosting or EU isolation formField: \"private-captcha-solution\", // custom form field name timeout: 10.0, // request timeout in seconds ); Non-standard backend domains \u003c?php use PrivateCaptcha\\Client; // Use EU domain $euClient = new Client( apiKey: \"your-api-key\", domain: Client::EU_DOMAIN // api.eu.privatecaptcha.com ); // Or specify custom domain in case of self-hosting $customClient = new Client( apiKey: \"your-api-key\", domain: \"your-custom-domain.com\" ); Retry Configuration \u003c?php $result = $client-\u003everify( solution: \"user-solution\", maxBackoffSeconds: 15, // maximum wait between retries attempts: 3 // number of retry attempts ); ","installation#Installation":" composer require private-captcha/private-captcha-php ","quick-start#Quick Start":" \u003c?php use PrivateCaptcha\\Client; // Initialize the client with your API key $client = new Client(apiKey: \"your-api-key-here\"); // Verify a captcha solution try { $result = $client-\u003everify(solution: \"user-solution-from-frontend\"); if ($result-\u003esuccess) { echo \"Captcha verified successfully!\"; } else { echo \"Verification failed: {$result}\"; } } catch (Exception $e) { echo \"Error: {$e-\u003egetMessage()}\"; } ","requirements#Requirements":" PHP 8.1+ cURL extension JSON extension ","usage#Usage":"Web Framework Integration Laravel Example \u003c?php use Illuminate\\Http\\Request; use PrivateCaptcha\\Client; use PrivateCaptcha\\Exceptions\\SolutionException; class FormController extends Controller { private Client $client; public function __construct() { $this-\u003eclient = new Client(apiKey: config('services.privatecaptcha.key')); } public function submit(Request $request) { try { // Verify captcha from form data $this-\u003eclient-\u003everifyRequest($request-\u003eall()); // Process your form data here return response('Form submitted successfully!'); } catch (SolutionException $e) { return response('Captcha verification failed', 400); } } } Symfony Example \u003c?php use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use PrivateCaptcha\\Client; use PrivateCaptcha\\Exceptions\\SolutionException; class FormController { private Client $client; public function __construct() { $this-\u003eclient = new Client(apiKey: $_ENV['PRIVATECAPTCHA_API_KEY']); } public function submit(Request $request): Response { try { $this-\u003eclient-\u003everifyRequest($request-\u003erequest-\u003eall()); // Process form data return new Response('Success!'); } catch (SolutionException $e) { return new Response('Captcha failed', 400); } } } "},"title":"PHP"},"/docs/integrations/python/":{"data":{"":" Note\nYou can also use reCAPTCHA-compatible /siteverify endpoint directly (especially if you already have working reCAPTCHA integration) like in the tutorial example, this SDK is just Python-idiomatic implementation with convenience features.\nThis is a server-side SDK, which you would use to verify captcha solution against Private Captcha API. This SDK does not solve puzzles on the client side (used to protect APIs).\nGitHub repository","configuration#Configuration":"Client Options from private_captcha import Client, EU_DOMAIN client = Client( api_key=\"your-api-key\", domain=EU_DOMAIN, # replace domain for self-hosting or EU isolation form_field=\"private-captcha-solution\", # custom form field name timeout=10.0, # request timeout in seconds ) Non-standard backend domains For EU isolation, you can use built-in constant EU_DOMAIN:\nfrom private_captcha import Client, EU_DOMAIN # Use EU domain eu_client = Client( api_key=\"your-api-key\", domain=EU_DOMAIN # api.eu.privatecaptcha.com ) # Or specify custom domain in case of self-hosting custom_client = Client( api_key=\"your-api-key\", domain=\"your-custom-domain.com\" ) Retry Configuration When verifying puzzle solutions, you can also specify some retry and backoff options.\nresult = client.verify( max_backoff_seconds=15, # maximum wait between retries attempts=3 # number of retry attempts ) ","installation#Installation":" pip install private-captcha ","quick-start#Quick Start":" from private_captcha import Client # Initialize the client with your API key client = Client(api_key=\"your-api-key-here\") # Verify a captcha solution try: result = client.verify(solution=\"user-solution-from-frontend\") if result.success: print(\"Captcha verified successfully!\") else: print(f\"Verification failed: {result}\") except Exception as e: print(f\"Error: {e}\") ","usage#Usage":"Web Framework Integration Flask Example from flask import Flask, request from private_captcha import Client, SolutionError app = Flask(__name__) client = Client(api_key=\"your-api-key\") @app.route('/submit', methods=['POST']) def submit_form(): try: # Verify captcha from form data client.verify_request(request.form) # Process your form data here return \"Form submitted successfully!\" except SolutionError: return \"Captcha verification failed\", 400 Django Example from django.http import HttpResponse from private_captcha import Client, SolutionError client = Client(api_key=\"your-api-key\") def submit_view(request): if request.method == 'POST': try: client.verify_request(request.POST) # Process form data return HttpResponse(\"Success!\") except SolutionError: return HttpResponse(\"Captcha failed\", status=400) "},"title":"Python"},"/docs/integrations/react/":{"data":{"":" Note\nYou can use a “default way” of adding \u003cdiv class=\"private-captcha\" ...\u003e\u003c/div\u003e element with https://cdn.privatecaptcha.com/widget/js/privatecaptcha.js Javascript include. But it will not work well with server-side rendering (e.g. in Next.js).\nThis is a client-side SDK for React, which is an alternative to using a standard script directly.\nGitHub repository","basic-usage#Basic Usage":" import React from 'react'; import { PrivateCaptcha } from '@private-captcha/private-captcha-react'; function MyForm() { const handleCaptchaFinished = (detail) =\u003e { console.log('Captcha solved!', detail.widget.solution()); // Submit your form here or enable the submit button }; return ( \u003cform\u003e \u003cinput type=\"text\" name=\"username\" placeholder=\"Username\" /\u003e \u003cinput type=\"password\" name=\"password\" placeholder=\"Password\" /\u003e \u003cPrivateCaptcha siteKey=\"your-site-key-here\" theme=\"dark\" onFinish={handleCaptchaFinished} /\u003e \u003cbutton type=\"submit\"\u003eLogin\u003c/button\u003e \u003c/form\u003e ); } ","examples#Examples":"EU-isolation For EU isolation you need to add eu=\"true\" attribute to the widget declaration:\n\u003cPrivateCaptcha siteKey=\"your-site-key\" eu={true} /\u003e ","installation#Installation":" npm install @private-captcha/private-captcha-react ","props-api#Props API":"Required Props Prop Type Description siteKey string Your Private Captcha site key Optional Props Please refer to the official widget options documentation.\nEvent Handler Props All event handler functions receive a detail object with these properties:\ndetail.widget - captcha object detail.element - The DOM element hosting the captcha Prop Type Description onInit (detail) =\u003e void Called when captcha is initialized onStart (detail) =\u003e void Called when solving starts onFinish (detail) =\u003e void Called when solving completes onError (detail) =\u003e void Called when an error occurs ","requirements#Requirements":" React 18+ "},"title":"React"},"/docs/integrations/wordpress/":{"data":{"":"This is a all-in-one plugin for WordPress that allows you to configure client-side captcha widget and server-side verification.\nGitHub repository","features#Features":" Form Protection: Login, registration, password reset, and comment forms Flexible Configuration: Theme, language, start mode, and custom styling options EU Compliance: Support for EU-only endpoints and custom domains WP-CLI Commands: Emergency management tools for API key updates and login bypass ","installation#Installation":" Note\nOfficial plugin for WordPress plugin directory is currently under review. For the time being, you need to upload plugin file manually to your WordPress to use it. Download plugin here.\nInstall and activate the plugin Go to Settings → Private Captcha Add your API Key and Site Key from Private Captcha Portal Enable desired form integrations Customize widget appearance as needed ","requirements#Requirements":" WordPress 5.6+ PHP 8.2+ Private Captcha account ","supported-forms#Supported Forms":" WordPress Login Form WordPress Registration Form WordPress Password Reset Form WordPress Comment Forms (logged-in and guest users) ","wp-cli-commands#WP-CLI Commands":"Emergency management when locked out:\n# Update API key wp private-captcha update-api-key \"your-new-api-key\" # Disable login captcha (emergency use) wp private-captcha disable-login "},"title":"WordPress"},"/docs/reference/":{"data":{"":"Reference of API and parameters that you can use.\nNote\nAPI is also available here as Swagger / OpenAPI definition.\nWidget options Verify API Captcha JS object Testing EU isolation "},"title":"Reference"},"/docs/reference/captcha-object/":{"data":{"":"Captcha object is available as the window.privateCaptcha.autoWidget or as attached via data-store-variable attribute. It is also passed as the only parameter into all of the callbacks.","methods#Methods":"solution() Returns the found solution. Can be used in callbacks for custom processing of the form.\nExample:\nfunction onCaptchaSolved(widget) { console.log('Found solution:', widget.solution()); } \u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" data-finished-callback=\"onCaptchaSolved\"\u003e\u003c/div\u003e reset() Resets capcha widget to the initial state. Deletes found solution. Optionally can accept an object with options, that correspond to the data-attributes, that are set on the widget itself. Please mind the name conversion rules for dataset attributes. For popup display mode, reset() will hide the widget.\nExample:\nwindow.privateCaptcha.autoWidget.reset(); // with options window.privateCaptcha.autoWidget.reset({debug: true, displayMode: 'popup'}); execute() Starts solving captcha puzzle, shows widget if needed (e.g. for display style popup). Can be used instead of default handler for forms (make sure not to use input type submit for the button).\nExample:\n\u003cform\u003e \u003cbutton type=\"button\" onclick=\"window.privateCaptcha.autoWidget.execute()\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e "},"title":"Captcha object"},"/docs/reference/eu-isolation/":{"data":{"":"There’s a way to use Private Captcha APIs in such a way that all requests are routed exclusively to our servers in EU locations.\nNote\nPrivate Captcha uses EU-only suppliers so by “servers in EU locations” we don’t mean a US-based company (e.g. AWS) with EU points of presence.\nTo achieve this you need to make 2 changes: one on the frontend and second on the backend.\nTL;DR; version is that you need to replace in your code api.privatecaptcha.com to api.eu.privatecaptcha.com and set data-eu=\"true\" in widget.","backend-changes#Backend changes":"SDKs When you’re using one of the integration SDKs you need to specify EU isolation during configuration.\nHere’s an example for Go:\nDiffFull code client, err := privatecaptcha.NewClient(privatecaptcha.Configuration{ APIKey: \"pc_abcdef\", + Domain: privatecaptcha.EUDomain, }) client, err := privatecaptcha.NewClient(privatecaptcha.Configuration{ APIKey: \"pc_abcdef\", Domain: privatecaptcha.EUDomain, }) reCAPTCHA-compatible API When you verify the form submission on the server side, you need to make POST request to the corresponding EU endpoint: https://api.eu.privatecaptcha.com/siteverify.\ncurl -X POST \\ -H \"X-Api-Key: your-api-key-here\" \\ -d \"solution\" \\ - https://api.privatecaptcha.com/siteverify + https://api.eu.privatecaptcha.com/siteverify ","frontend-changes#Frontend changes":"To make sure captcha widget only talks to EU APIs you need to set a data-eu to true in the widget declaration:\nDiffFull code \u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" ... + data-eu=\"true\" ... \u003e \u003c/div\u003e \u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" data-eu=\"true\"\u003e \u003c/div\u003e Note\nThis does not affect the captcha widget Javascript snippet itself which loads from CDN points of presence over the world to decrease latency. No end-user PII is involved.","implications#Implications":"The cost of EU isolation is the potential slowdown of the initial widget initialization, in case the end-user is accessing website geographically far from Europe. In most cases it should not be noticeable to the end-user as most operations happen strictly in the background."},"title":"EU Isolation"},"/docs/reference/property-settings/":{"data":{"":"Protection of a website or a form starts with creating a property in the Portal. Property corresponds to a single CAPTCHA widget - it can be used on a website, a particular web page, form, subdomain etc. Property is identified by a Site Key, which looks like aaaaaaaabbbbccccddddeeeeeeeeeeee. Site Key is used in the widget initialization.\nWe’ll go through all property settings that you can change.","challenge-difficulty#Challenge difficulty":"Each CAPTCHA challenge has a certain “difficulty”. Difficulty corresponds to the amount of resource the client has to use in order to “solve” the challenge. The higher the difficulty, more resources are required to “solve” (pass) the challenge.\nPrivate Captcha offers dynamic (automatically scaled) difficulty out of the box in all plans. This means when there are more requests, the difficulty of each subsequent challenge will grow, and when there are less requests, it will fall back to base settings. This is the basis of the security of scale.\nBase difficulty This is the “default” challenge difficulty level when there are no user requests at all. You can test how does it feel using the playground right below those settings.\nDifficulty growth When user (or bots) requests to your resources (websites, forms, API) keep coming, Private Captcha automatically scales the difficulty. You have 3 options of how fast the difficulty changes based on the number of requests:\nConstant (difficulty does not change at all and the value you set will always be returned) Slow (difficulty changes slower than usual, it will take more requests to increase the difficulty on average) Normal (default setting of difficulty growth) Fast (difficulty growth is very reactive and will grow faster as more requests come) ","challenge-verification#Challenge verification":"Verification window Captcha challenges (or “puzzles”) have a validity period during which they can be “solved” and verified. You can set validity period from few minutes to a couple of days. If a CAPTCHA solution is checked outside of validity period, it’s considered invalid.\nRepeated solutions Note\nThis is an advanced setting that allows to build different applications out of Private Captcha API.\nBy default you cannot submit a solution to the same CAPTCHA puzzle more than once. Second time it will be considered invalid. This is a protection against so called “replay attack”, where a malicious actor solves puzzle only once, but sends your form or accesses your page multiple times.\nHowever, there are cases when you want to allow this. One example if when Private Captcha is used as a proxy in front of your website, like in the use-case of AI scrapers protection (or API endpoints protection). In such case when the user requests a webpage with a valid solution (solved challenge/puzzle), we want to grant them access, up to a certain number of times.\nThis is where the setting with the number of repeated solutions comes into play. If you set the value to, say, 5, it means user can solve the CAPTCHA puzzle once to access your resources 5 times before being requested to pass another challenge. The exact number you want to use is the trade off between annoying your user base and protecting your resources against automated access or AI scrapers.","domain#Domain":"You set domain when you create the property in the Portal. You can change the property name, but you cannot change Domain.\nSubdomains By default CAPTCHA requests are only allowed on the domain that you used to create the property. If you created property with domain example.com, then you cannot use the same widget on portal.example.com. However, if you enable “Allow subdomains” checkbox, all subdomains are allowed.\nLocalhost In the lieu of the “Subdomains” logic, localhost access (for development) is also not allowed by default (in that case anybody can use your property Site Key locally). But you can temporarily enable “Allow localhost” for development purposes. In that case you will have a “testing” label added to your property."},"title":"Property settings"},"/docs/reference/testing/":{"data":{"":"There’re 2 main ways how you can keep using Private Captcha for testing of your local website:\nuse a predefined (“dummy”) sitekey allow localhost access for main property in Settings in portal ","testing-with-localhost-access#Testing with localhost access":" Warning\nCaptcha has a strict CORS policy and, by default, it will load only on the domain configured during property creation. Subdomains and localhost access needs to be explicitly allowed.\nIn order to make captcha widget to load on localhost domain, we need to allow it in the settings of the property you just created.\nWorth noting that this is not required if you use the dummy sitekey.","testing-with-predefined-sitekey#Testing with predefined sitekey":"Recommended way to use Private Captcha for development is to use different sitekeys for production and testing. For testing you can use a “dummy” sitekey (aka “test property”): aaaaaaaabbbbccccddddeeeeeeeeeeee. This sitekey does not incur any actual solving “price” (in compute resources) on the frontend and the result always passes verification. Please note that captcha widget still has to be clicked to pass by default, unless you are using data-start-mode=\"auto\" (in which case parent form needs to gain focus).\nClient side This is a sample captcha widget for testing:\n\u003cdiv class=\"private-captcha\" data-sitekey=\"aaaaaaaabbbbccccddddeeeeeeeeeeee\"\u003e \u003c/div\u003e Note\nWidget will show red \"testing\" text to highlight that it’s not for production use once you click it.\nServer side On the server side, once you are using Verify API, all responses will contain { \"success\": true } (“verification passed”) and { \"error-codes\": [\"property-test\"] } (non-empty error codes). Of course, you should be mainly checking success field and error-codes semantics is just to distinguish actual errors.\nSending verify request This is a sample payload for test property, that should always return “success” (please note this is for illustration purposes only as payload can change)\ncurl \\ -X POST \\ -H \"X-Api-Key: your-api-key\" \\ -d \"AQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.Aaqqqqq7u8zM3d3u7u7u7u4AAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAA=.AQCBnM2czBK6rlq+l06lXBtIDQH/PFk=\" \\ https://api.privatecaptcha.com/verify And if everything is set up correctly, the output will be\n{\"success\":true,\"code\":10,\"timestamp\":\"0001-01-01T00:00:00Z\",\"origin\":\"\"} Code 10 corresponds to \"property-test\" error description."},"title":"Testing"},"/docs/reference/verify-api/":{"data":{"":" Note\nThere’re many ready integrations available and API is also available here as Swagger / OpenAPI definition.\nAfter captcha widget has finished solving the puzzle, it adds a hidden form field with solution (defined by data-solution-field attribute).\n\u003cform\u003e \u003c!-- ... --\u003e \u003cinput name=\"private-captcha-solution\" type=\"hidden\" value=\"AAAAAAACAhQEAOiDAAAAAAC...IsoSTgYAAA=\"\u003e \u003c!-- ... --\u003e \u003c/form\u003e When handling form submission on the server-side, this is the field you need to validate using Private Captcha API.","error-codes#Error codes":" Note\nIf code is not zero, it does not mean that verification failed. See details below.\nDefault /verify endpoint should be used with one of the integration SDKs which allow you to get a string description of the numeric error code.\nreCAPTCHA-compatible /siteverify endpoint will contain the string version in error-codes field.\ncode can be one of the error codes:\nError code Description no-error No error (shown here for completeness) error-other Unspecified error solution-duplicates Solution contains duplicates solution-invalid Solution verification error solution-bad-format Solution has invalid format puzzle-expired Puzzle for this solution has expired property-invalid Property for this puzzle/solution cannot be found property-owner-mismatch Property and API key’s accounts don’t match solution-verified-before Solution has been already verified property-test Test property is used for verification maintenance-mode Maintenance mode (see below) integrity-error Puzzle or solution integrity is compromised Errors during successful verification There are a couple of cases, when success in response will be equal to true (successful verification), but code will not be zero. This is made in order to help you distinguish certain use-cases of captcha (and decide yourself if you trust submissions):\nWhen you’re using a test property, code will be property-test (but verification will succeed). During maintenance mode, Private Captcha still verifies cryptographic solution validity, however, account validity might not be possible to verify. If solution is valid, success in response is equal to true, but code will be maintenance-mode. If you configured property to “Accept repeated solutions” (during verification window), verification of repeated solution will cause code to be solution-verified-before. ","request#Request":"To verify solutions you need to make a POST request to https://api.privatecaptcha.com/verify with the body of the request being solution field’s contents from your form.\n# an example how that will look like with curl curl -X POST \\ -H \"X-Api-Key: your-api-key-here\" \\ -d \"solution\" \\ https://api.privatecaptcha.com/verify Note\nUsually you would not send that POST request yourself, but use one of our pre-built integrations.","response#Response":"Here’s how a successful response from /verify endpoint looks like:\n{ \"success\": true, \"timestamp\": \"2025-01-13T16:17:27+00:00\", \"origin\": \"privatecaptcha.com\", \"code\": 0 } Verifying captcha Verification status is defined by a single field only: success (boolean) must be equal to true."},"title":"Verify API"},"/docs/reference/widget-options/":{"data":{"":"Here’s the minimal captcha field declaration:\nindex.html\u003cdiv class=\"private-captcha\" data-sitekey=\"abcdef\"\u003e\u003c/div\u003e Private Captcha widget is automatically initialized on all elements with private-captcha class name.","attributes#Attributes":"Apart from the required sitekey data attribute, the following optional attributes are supported:\nAttribute Values Description data-start-mode auto, click In auto mode (default) captcha widget starts solving captcha whenever parent form receives focus. data-debug true When set to true, will show widget’s internal state and print debug logs. data-solution-field private-captcha-solution, your value Name of the hidden form field with captcha solution that has to be verified on the server side. data-eu true When set to true, will make widget to use only EU endpoints for EU-isolation. data-puzzle-endpoint '' or your value Endpoint to get captcha puzzle (override in case of self-hosting). data-display-mode widget, popup, hidden How captcha widget will be shown. Defaults to widget. When hidden, you need to setup widget callbacks (see below). data-lang en Captcha widget localization. data-theme light, dark Widget theme (defaults to light) data-styles {valid CSS} Overrides for host variables of the widget’s web component, on top of theme. data-store-variable {JS variable name} If present, attaches Captcha Object to the html element (helps with multiple widgets on a page) Notes and examples data-display-mode widget is the default display mode of captcha\npopup captcha widget appears relative to the first parent that has a class private-captcha-anchor.\n\u003cform\u003e \u003cdiv class=\"private-captcha-anchor\"\u003e \u003cdiv class=\"private-captcha\" data-display-mode=\"popup\" data-sitekey=\"xyz\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c!-- ... --\u003e \u003cbutton type=\"button\" onclick=\"window.privateCaptcha.autoWidget.execute()\"\u003eClick me!\u003c/button\u003e \u003c/form\u003e Click me! hidden captcha widget is permanently hidden and you need to handle all callbacks yourself. See example.\ndata-lang data-lang allows you to show widget localization in your own language. Translations are defined in the widget/js/strings.js file. If translation to your language is not there, feel free to contribute it.\nHere’s the list of currently supported languages:\nEnglish (en) Deutsch (de) Español (es) Français (fr) Italiano (it) Nederlands (nl) Svenska (sv) Norsk (no) Polski (pl) Suomi (fi) Eesti (et) Here’s how to localize a widget:\nindex.html@@ -32,7 +32,7 @@ \u003cdiv class=\"private-captcha\" + data-lang=\"de\" data-sitekey=\"xyz\"\u003e \u003c/div\u003e data-theme TIP: Use theme toggle on this website to check how the widget will look like\nlight theme dark theme data-styles data-styles allows you to override some of the widget styles to better fit into your website’s design, on top of data-theme. Example of override: data-style=\"--border-radius: .75rem;\".\nThe following variables support overrides (but in general are not encouraged to change).\nColors:\n--dark-color --gray-color --pie-color --background-color --checkbox-background-color --checkbox-hover-color --accent-color --warn-color Spacing:\n--border-radius --extra-spacing (adds equal distance from sides and between checkbox and label) --label-spacing (“base” distance from checkbox and label) Additionally, you can change the following CSS properties:\ndisplay (defaults to inline-block, set to block together with height: 100%; to “stretch” widget) font-size (defaults to 1rem, change to “scale” widget) Making LARGE widget There’re 2 things you can do: changing font-size scales everything inside the widget and stretching widget itself is done with display attribute (which by default is inline-block).\n\u003cform style=\"width: 500px; height: 160px;\"\u003e \u003cdiv class=\"private-captcha\" style=\"height: 100%\" data-styles=\"display: block; height: 100%; font-size: 24px;\"\u003e \u003c/div\u003e \u003c/form\u003e data-store-variable Captcha object, that is created from the widget configuration, provides a number of APIs.\nIf this is the only captcha widget on a page, you can access this object via window.privateCaptcha.autoWidget.\nHowever, in case of multiple widgets, you can assign this attribute to a variable name and then access it as a field of the HTMLElement.\n\u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" id=\"pcWidget\" data-store-variable=\"_privateCaptcha\"\u003e\u003c/div\u003e \u003c!-- Used in the onclick --\u003e \u003cbutton type=\"button\" onclick=\"document.getElementById('pcWidget')._privateCaptcha.execute()\"\u003e Submit \u003c/button\u003e ","events-and-callbacks#Events and Callbacks":"Element, where private-captcha class is set, will receive various lifecycle events (alternative to Callbacks). All events receive a detail parameter with widget (Captcha Object) and element properties. As an alternative, you can set data attributes with JavaScript handlers (all callbacks receive a single argument which is the Captcha Object itself).\nEvent Callback Description privatecaptcha:init data-init-callback Widget has received a new puzzle to solve (possibly after previous puzzle expiration). privatecaptcha:start data-started-callback Captcha started solving the puzzle. privatecaptcha:finish data-finished-callback Puzzle has been solved. You can use this callback to enable the form submit button. privatecaptcha:error data-errored-callback Puzzle endpoint is not reachable or puzzle solving has failed Example index.html\u003cform\u003e \u003cdiv class=\"private-captcha\" data-finished-callback=\"onCaptchaSolved\"\u003e \u003c/div\u003e \u003c/form\u003e script.jsfunction onCaptchaSolved(widget) { console.log('Solved!'); } ","explicit-rendering#Explicit rendering":"All the above assumed that when you include the JavaScript privatecaptcha.js, it automatically initializes all of the elements with CSS class private-captcha. However, it’s possible to omit that and instead do it manually in JavaScript.\nTo achieve that, you need to add parameter ?render=explicit to the script include:\nindex.html@@ -18,7 +18,13 @@ - \u003cscript src=\"https://cdn.privatecaptcha.com/widget/js/privatecaptcha.js\" defer\u003e\u003c/script\u003e + \u003cscript src=\"https://cdn.privatecaptcha.com/widget/js/privatecaptcha.js?render=explicit\" defer\u003e\u003c/script\u003e Then, you can use function privateCaptcha.render(htmlElement, options) to explicitly render captcha widget. options parameter allows to set properties with the same names as data-attributes above, taking into account the naming convention."},"title":"Widget options"},"/docs/tutorials/":{"data":{"":"Here you can find tutorials with code examples that you can copy and paste.\nComplete example Invisible captcha reCAPTCHA migration "},"title":"Tutorials"},"/docs/tutorials/complete-example/":{"data":{"":"In this tutorial we will create a simple html form, serve it locally with a simple web-server, then protect using Private Captcha and, finally, verify form submission. And all this in the comfort of your own computer (meaning, you don’t have to have a running server in the cloud).","add-captcha-widget-to-the-form#Add captcha widget to the form":"This assumes that you already have an account with Private Captcha. If you don’t, go ahead and create one.\nCreate new property In the dashboard, click “Add new property”:\nFor a domain, enter any valid domain (if you used ngrok in the previous step, add the generated domain):\nAfter property is created, we will be presented with the integration snippet:\nAdd captcha widget to the form To integrate the widget, we need to add javascript include for privatecaptcha.js and the widget itself to the form. You can get them from the integration snippet above.\nNote\nMake sure to use your own sitekey\nindex.html \u003c/style\u003e + \u003cscript defer src=\"https://cdn.privatecaptcha.com/widget/js/privatecaptcha.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"display: flex; flex: 1 1 0%\"\u003e \u003cform action='/submit' method=\"POST\"\u003e \u003clabel\u003e Email: \u003c/label\u003e \u003cinput type=\"email\" name=\"email\" placeholder=\"Email address\" required /\u003e + \u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\"\u003e\u003c/div\u003e \u003cbutton id=\"formSubmit\" type=\"submit\" disabled\u003e Submit \u003c/button\u003e \u003c/form\u003e \u003c/div\u003e If you did everything correctly, when you refresh the page (and/or restart your server), you will see the captcha widget inside your form:\nWarning\nCaptcha has a strict CORS policy and, by default, it will load only on the domain configured during property creation. Subdomains and localhost access needs to be explicitly allowed.\nIn order to make captcha widget to load on localhost domain, we need to allow it in the settings of the property you just created (this is not required if you used ngrok domain).\nHowever, currently captcha widget is not yet particularly useful as we do not take it into account when submitting the form.","basic-webpage-and-server#Basic webpage and server":" ./ index.html main.go Create a simple page with a form element in the middle of the page.\nindex.html\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003ePrivate Captcha Example\u003c/title\u003e \u003cstyle\u003e body { display:flex; flex-direction: column; min-height: 100vh; } form { max-width: 32rem; margin: auto; display: flex; flex-direction: column; gap: 20px; border: 1px #ccc solid; padding: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"display: flex; flex: 1 1 0%\"\u003e \u003cform action='/submit' method=\"POST\"\u003e \u003clabel\u003e Email: \u003c/label\u003e \u003cinput type=\"email\" name=\"email\" placeholder=\"Email address\" required /\u003e \u003cbutton id=\"formSubmit\" type=\"submit\" disabled\u003e Submit \u003c/button\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e And a web-server that will serve it (Go is used here as an example).\nGo main.gopackage main import ( \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { if r.URL.Path == \"/\" { http.ServeFile(w, r, \"index.html\") return } // Return 404 for any other paths http.NotFound(w, r) }) if err := http.ListenAndServe(\":8081\", nil); err != nil { log.Fatal(err) } } You can run it using go run main.go and open http://localhost:8081/ in the browser.\nHere’s how it looks like in Firefox:\n(optional) Making this server available publicly We can use ngrok for this purpose, but you can use any compatible solution, such as CloudFlare Tunnel or even reverse SSH tunnel from your own server.\n# run ngrok to our previously exposed port 8081 ngrok http 8081 This will give you a public domain, in this case, https://27ca-193-138-7-216.ngrok-free.app. You can verify that it’s working by opening it from your terminal.\nYou can use this domain as a property domain below.","finale#Finale":"Test your form Now you can finally click “Submit” on your page and see if you get a “green result” in the end.\nNow, if you did everything correct, your property dashboard in portal will also show some activity.\nAnd, if you print verify response to the console, you will get this json:\n{\"success\":true,\"code\":0,\"timestamp\":\"2025-01-14T11:19:34Z\",\"origin\":\"27ca-193-138-7-216.ngrok-free.app\"} Full code Congratulations on completing this tutorial! You can find full code in this gist.\nTroubleshooting To access browser logs you can add data-debug=\"true\" attribute to the widget and then see if there are any errors in the console.\nCaptcha verification fails (you see a red page) localhost was not allowed in the property settings for deployments, different from privatecaptcha.com, you also need to set data-puzzle-endpoint=\"https://api.your-domain.com/puzzle\" attribute ","integrating-with-private-captcha#Integrating with Private Captcha":"Client-side In our simple web-page, let’s add a JavaScript function to enable the “Submit” button when captcha is solved.\nDiffCode index.html@@ -18,7 +18,13 @@ padding: 20px; } \u003cscript defer src=\"https://cdn.privatecaptcha.com/widget/js/privatecaptcha.js\"\u003e\u003c/script\u003e + \u003cscript type=\"text/javascript\"\u003e + function onCaptchaSolved() { + const submitButton = document.querySelector('#formSubmit'); + submitButton.disabled = false; + } + \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e index.html\u003cscript type=\"text/javascript\"\u003e function onCaptchaSolved() { const submitButton = document.querySelector('#formSubmit'); submitButton.disabled = false; } \u003c/script\u003e and connect this function to the widget itself by adding data-finished-callback attribute:\nindex.html@@ -32,7 +32,7 @@ \u003cform action='/submit' method=\"POST\"\u003e \u003clabel\u003e Email: \u003c/label\u003e \u003cinput type=\"email\" name=\"email\" placeholder=\"Email address\" required /\u003e - \u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\"\u003e\u003c/div\u003e + \u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" + data-finished-callback=\"onCaptchaSolved\"\u003e\u003c/div\u003e \u003cbutton id=\"formSubmit\" type=\"submit\" disabled\u003e Submit \u003c/button\u003e \u003c/form\u003e \u003c/div\u003e Now client-side should be ready. What is left is only to verify captcha on the server-side.\nServer-side For server-side, we need to add a handler for the form and verify captcha solution.\nCreate a new API key To verify captcha solutions, we need an API key. Head to the portal, open your user’s Settings, then API keys and click “Create new key”.\nAdd code to verify solution After captcha widget has finished solving the puzzle, it adds a hidden form field with solution (defined by data-solution-field attribute).\n\u003cform\u003e \u003c!-- ... --\u003e \u003cinput name=\"private-captcha-solution\" type=\"hidden\" value=\"AAAAAAACAhQEAOiDAAAAAAC...IsoSTgYAAA=\"\u003e \u003c!-- ... --\u003e \u003c/form\u003e To verify solution we need to send a POST request with the contents of this field to /verify endpoint and check the result. This is done in the server-side handler of the form.\nWarning\nBelow we are using API directly only for demonstration purposes. Most likely you want to use of of the integration SDKs that are available for popular languages.\nNote\nMake sure to use your own API key\nDiffGo main.go@@ -1,11 +1,60 @@ ) +func checkSolution(solution, apiKey string) error { + req, err := http.NewRequest(\"POST\", \"https://api.privatecaptcha.com/verify\", strings.NewReader(solution)) + if err != nil { + return err + } + + req.Header.Set(\"X-Api-Key\", apiKey) + + resp, err := http.DefaultClient.Do(req) + if err != nil { + return err + } + defer resp.Body.Close() + + response := struct { + Success bool `json:\"success\"` + // NOTE: other fields omitted for brevity + }{} + + if err := json.NewDecoder(resp.Body).Decode(\u0026response); err != nil { + return err + } + + if !response.Success { + return errors.New(\"solution is not correct\") + } + + return nil +} + func main() { + http.HandleFunc(\"POST /submit\", func(w http.ResponseWriter, r *http.Request) { + const page = `\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003cbody style=\"background-color: %s;\"\u003e\u003c/body\u003e\u003c/html\u003e` + captchaSolution := r.FormValue(\"private-captcha-solution\") + if err := checkSolution(captchaSolution, \"your-api-key\"); err != nil { + fmt.Fprintf(w, page, \"red\") + return + } + fmt.Fprintf(w, page, \"green\") + }) + http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { if r.URL.Path == \"/\" { http.ServeFile(w, r, \"index.html\") main.goimport ( \"encoding/json\" \"errors\" \"fmt\" \"log\" \"net/http\" \"strings\" ) func checkSolution(solution, apiKey string) error { req, err := http.NewRequest(\"POST\", \"https://api.privatecaptcha.com/verify\", strings.NewReader(solution)) if err != nil { return err } req.Header.Set(\"X-Api-Key\", apiKey) resp, err := http.DefaultClient.Do(req) if err != nil { return err } defer resp.Body.Close() response := struct { Success bool `json:\"success\"` // NOTE: other fields omitted for brevity }{} if err := json.NewDecoder(resp.Body).Decode(\u0026response); err != nil { return err } if !response.Success { return errors.New(\"solution is not correct\") } return nil } func main() { http.HandleFunc(\"POST /submit\", func(w http.ResponseWriter, r *http.Request) { const page = `\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003cbody style=\"background-color: %s;\"\u003e\u003c/body\u003e\u003c/html\u003e` captchaSolution := r.FormValue(\"private-captcha-solution\") if err := checkSolution(captchaSolution, \"your-api-key\"); err != nil { fmt.Fprintf(w, page, \"red\") return } fmt.Fprintf(w, page, \"green\") }) // .... } "},"title":"Complete example"},"/docs/tutorials/invisible-captcha/":{"data":{"":"Invisible captcha refers to the situation when you don’t want to show captcha widget for various reasons (e.g. custom UI integraion or design restrictions).","example#Example":"Here’s how a more complete example of the above looks like:\nHTMLJavascript \u003cform\u003e \u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" data-display-mode=\"hidden\" data-start-mode=\"click\" data-started-callback=\"invisibleCaptchaStarted\" data-finished-callback=\"invisibleCaptchaFinished\"\u003e \u003c/div\u003e \u003cbutton type=\"button\" onclick=\"window.privateCaptcha.autoWidget.execute()\"\u003e \u003csvg id=\"spinner\" ... /\u003e \u003csvg id=\"checkmark\" ... /\u003e Submit \u003c/button\u003e \u003c/form\u003e function invisibleCaptchaStarted() { document.getElementById('spinner').classList.remove('hidden'); document.getElementById('checkmark').classList.add('hidden'); } function invisibleCaptchaFinished(widget) { setTimeout(() =\u003e { document.getElementById('spinner').classList.add('hidden'); document.getElementById('checkmark').classList.remove('hidden'); }, 1500); setTimeout(() =\u003e { widget.reset(); document.getElementById('spinner').classList.add('hidden'); document.getElementById('checkmark').classList.add('hidden'); }, 3000); } Demo You can try the above setup by clicking this button:\nSubmit ","setup#Setup":"To permanently hide the widget, set data-display-mode attribute to hidden.\n\u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" ... + data-display-mode=\"hidden\" ... \u003e \u003c/div\u003e Additionally, you need to supply callbacks for at least 2 events: data-started-callback and data-finished-callback.\n\u003cdiv class=\"private-captcha\" data-sitekey=\"xyz\" ... + data-started-callback=\"invisibleCaptchaStarted\" + data-finished-callback=\"invisibleCaptchaFinished\" ... \u003e \u003c/div\u003e Triggering solving By default, captcha will begin solving when any input from the parent form will receive input. For example, it will happen when you fill out input fields or click the Submit button.\nHowever, if you want to control when the solving will start, you can set data-start-mode attribute to click and trigger solving captcha using API method execute()."},"title":"Invisible captcha"},"/docs/tutorials/migrate-from-recaptcha/":{"data":{"":"You can migrate from Google reCAPTCHA “fast” using compatibility mode for server-side and client-side parts or you can fully migrate to Private Captcha.\nTo proceed with migration, in Private Captcha portal you need to get a sitekey for client-side (property integrations) and API key for backend (account settings).","fast-migration#Fast migration":"“Fast” migration makes it possible to migrate with absolutely minimal amount of changes to front-end or backend-end to use your existing integration code.\nClient-side Private Captcha offers a compatibility mode for the website integration: just add ?compat=recaptcha script parameters when you include Private Captcha script.\nindex.html@@ -18,7 +18,13 @@ - \u003cscript src=\"https://www.google.com/recaptcha/api.js\" async defer\u003e\u003c/script\u003e + \u003cscript src=\"https://cdn.privatecaptcha.com/widget/js/privatecaptcha.js?compat=recaptcha\" defer\u003e\u003c/script\u003e Compatibility mode means the following:\nsolution form field will be called g-recaptcha-response instead of private-captcha-solution Private Captcha JavaScript object is available as grecaptcha global property Private Captcha looks for elements with g-recaptcha class instead of private-captcha for automatic widget rendering All compatible global APIs for reCAPTCHA like render() or getResponse() are also present Note\nPrivate Captcha offers invisible mode with execute() API too\nExplicit rendering By default, when you include the client script, Private Captcha initializes all elements that have g-recaptcha class attached (that is, in reCAPTCHA compatibility mode).\nHowever, you can also explicitly render captcha elements using window.grecaptcha.render(htmlElement, options) API. To do so, add another argument to Javascript script include: render=explicit and then explicitly call render() for all elements that you need.\nServer-side Private Captcha offers reCAPTCHA compatible API endpoint /siteverify, that you can use like this:\n- \"https://www.google.com/recaptcha/api/siteverify\" + \"https://api.privatecaptcha.com/siteverify\" Warning\nGoogle reCAPTCHA also supports GET request type to /siteverify endpoint (in addition to POST), but Private Captcha only supports POST\nBy default endpoint returns responses in reCAPTCHA v2 format. In case you are using reCAPTCHA v3, you need to add an additional header X-Captcha-Compat-Version: rcV3 to your requests and response will follow v3-compatible API.","full-migration#Full migration":" Note\nFull migration is recommended as it is quite easy and it uses more efficient codepaths.\nTo migrate from reCAPTCHA completely, you need to rely on Private Captcha semantics on the client-side and use one of the pre-built integrations on the server side.\nClient-side Even without compatibility mode (above), Private Captcha offers a similar client-side API as reCAPTCHA, so migration shouldn’t cause a lot of pain.\nThings you generally will need to do:\nreplace script src address to use the Private Captcha one replace added class g-recaptcha to private-captcha for automatic/implicit rendering (the default) replace usage of grecaptcha global object (if any) to privateCaptcha change stub sitekeys for testing, if you have any You can check full widget documentation for front-end details.\nServer-side Private Captcha offers a lot of pre-built integrations so your backend technology is very likely covered. If not, you can rely on OpenAPI spec to generate your client (or write one yourself, as it’s doing only a single POST request to an API endpoint)."},"title":"Migrate from reCAPTCHA"}}